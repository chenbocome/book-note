## 第1章 初识C++
- 与Visual Studio一起安卓的构建工具有：MSBuild和nmake。当用Visual Studio环境下构建一个Visual C++项目时，将使用MSBuild，并且会把编译规则存放在一个XML文件中。nmake是Microsoft在做个编译器之间维护程序多个版本的实用性工具。
- 编译器配置的内存称为栈帧(stack frame)。编译器中包含如何创建栈帧的选项，比如Microsoft的编译器选项`/Gd`、`/Gr`、`/Gz`决定了函数参数被推到堆栈上的次序，以及调用放函数与被调用函数在调用结束时是否应该从堆栈中移除这些参数。当我们变得代码需要和其他人共享时，这些选项将非常重要。
- 默认情况下，Microsoft编译器将显示1级别警告信息，你可以使用`/W`选项和一个数字来生命希望看到的警告级别(比如，`/W2`表示用户希望看到2级警告以及1级警告)。
- 一个C++项目将始终包含两个阶段：先将源代码编译成一个或者多个对象文件，然后将这些对象文件链接到一个可执行程序中。
- 链接器也有决定它如何工作并指定输出和输入的选项供用户选择，并且它还会向我们发出错误与告警信息。与编译器类似，Microsoft的链接器也有一个选项`/WX`，它可以将预览版程序中的警告信息当作错误来处理。
- C++中，如果函数声明了返回值，那么它必须返回一个值。不过，该规则存在一个例外情况：如果main函数没有返回值，那么系统默认会将0作为它的返回值。
- main函数参数解释

        void main(int argc,char *argv[])
        {
            for(int i=0;i<argc;i++)
            {
                cout<<"argument["<<i<<"] is: "<<argv[i]<<endl;
            }
            system("pause");
        }
	- `argc` 是 argument count的缩写，表示传入main函数的参数个数；
	- `argv` 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数`argv[0]`一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个；
- `pragma`是专属与编译器的指令，不同编译器支持的`pragma`也不尽相同。
	- Visual C++定义的`#pragma once`指令是为了解决多个头文件重复引用相同头文件的问题。
- 编译程序的库一般有两种：静态库和动态链接库
	- 如果使用的是静态库，那么编译器将从静态库中拷贝我们所需的代码，并将它们集成到可执行程序中。
	- 如果使用的是动态链接（共享）库，那么连接器将在程序运行过程中（有可能是在可执行程序被加载后，或者可能被推迟到函数被调用时）添加一些信息，以便将共享库加载到内存中并访问其功能特性。
- Windows使用`lib`作为静态库的文件扩展名，用`dll`作为动态链接库的文件扩展名。
- GNU gcc使用`a`作为静态库的文件扩展名，使用`so`作为共享库的文件扩展名。
- 如果你所需的代码在某个静态库或者动态链接库中，编译器将需要精准地知道你调用函数的信息，以便确保函数调用时使用正确的参数个数和类型，这也是函数原型的主要用途：它在不提供实际函数体的情况下，为编译器提供了调用函数所需的信息，即函数定义。
- 为了解决“每次编译代码时，在头文件中定义的代码也会被编译，即使头文件中的代码没有发生任何变化。对于大型项目，这使得编译过程中需要耗费很长时间才能完成。”问题，编译器通常会提供一个选项，对没有发生变更的头文件进行预编译。
- 预编译头文件的创建和使用是特定于编译器的。
	- 比如GNU C++编译器gcc，如果编译的某个头文件是一个C++源代码文件，该编译器会创建一个扩展名为`gch`的文件。当gcc编译源代码文件需要用到该头文件时，它会去搜索该`gch`文件。如果它找到了该预编译头文件，将使用它；否则，它会使用对应的头文件。
	- Visual C++项目的约定是提供一个名为`stdafx.cpp`的源文件，其中包含一行引用`stdafx.h`的代码。你可以在`stdafx.h`文件中引用所有性能稳定的头文件。然后可以通过编译`stdafx.cp`p文件来创建一个预编译头文件，同时使用`/Yc`编译器选项声明所有性能稳定并且需要被编译的文件都包含在了`stdafx.h`文件中。这将创建一个`pch`文件，其中包含经过编译的所有`stdafx.h`头文件中引用的代码。
- 在编译时，编译器必须能够通过某个头文件或者函数定义本身，在当前源代码文件中访问函数的定义。
- 编译器在源代码中将不会向前查找，因此如果函数A准备调用函数B，那么统一源代码文件中函数B必须在函数A调用它之前就已经被定义，否则必须存在一个对应的原型声明。这导致了一个非常典型的约定：
	- 即每个包含头文件的源代码文件包含函数的原型声明，并且该源文件引用上述头文件。