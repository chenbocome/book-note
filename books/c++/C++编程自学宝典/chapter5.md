## 第5章 函数
- 函数原型并不一定必须包含参数名称。这是因为编译期间只需要知道参数的类型，而不是它们的名称。
- 内联化
	- 如果函数中计算某个值的操作可以在编译期间执行，那么我们可以在语句声明的左边使用关键字`constexpr`对它进行标记，以告知编译期在编译代码时计算它的值，从而达到优化代码性能的目的。
	- 如果函数值可以在编译过程中计算，则意味着必须在编译期间获知函数中的参数，因此它们必须是字面值。
	- 该函数也必须是一个单行函数。如果不符合这些条件，那么编译器将自行忽略这些声明符。
	- `inline`当其他代码调用函数时，它可以被放置在函数声明的左边作为一个提示编译器的标记，而不是让编译器在内存中插入一个到该函数的跳转，编译器应该将实际的代码副本放在调用函数中、此外，编译器可以自行忽略该声明符。
- 返回类型
	- 第一种是在函数名前面指定返回类型。
	- 第二种方法称为函数返回类型后置，需要用户将关键字`auto`放在函数名前面作为发回来类型，并使用`->`语法在参数列表后面给出实际的返回值类型。

			inline auto mult(int lhs, int rhs) -> int
            {
            	return lhs*rhs;
            }
	- 当函数被模板化并且返回类型可能不明显时，第二种语法很有用。
- 如果一个函数根本不会返回任何职，可以使用C++11属性`[[noreturn]]`对它进行标记。编译器可以根据这个属性编写出更高效的代码。
- 声明异常

		int calculate(int param) throw(overflow_error, other_error)//异常类型列表，逗号分隔
        {
        }
        int calculate(int param) throw(...)//可能抛出任何异常
        {
        }
        int calculate(int param) throw()//不会抛出异常
        {
        }
        //C++11风格，不会抛出异常
        int calculate(int param) noexcept
        {
        }
- lambda表达式用在将要使用函数对象的地方创建一个匿名函数对象，这可以让代码更易读。